# DDH-based Private Intersection-Sum 协议详细分析

该协议是一种基于 **判定性迪菲-赫尔曼问题（Decisional Diffie-Hellman, DDH）** 的隐私保护集合交集求和协议。其核心目标是让持有各自数据集的双方（P1 和 P2），在不泄露各自数据内容的前提下，安全地计算出其数据集交集部分的关联数值之和。

---

### **1. 协议核心思想**

该协议巧妙地融合了多种密码学技术来实现其隐私保护目标：

* **迪菲-赫尔曼密钥交换思想**：协议的核心步骤利用了 `(H(v)^k1)^k2 = (H(v)^k2)^k1` 这一原理来识别交集。双方分别用自己的私钥对哈希后的元素进行指数运算，只有当元素相同时，双方计算出的结果才会相同。
* **加法同态加密 (Additive Homomorphic Encryption)**：为了计算交集元素的关联值之和而不泄露单个关联值，协议采用了加法同态加密方案。该方案允许在密文上直接进行加法运算，其结果解密后等于明文的和。
* **哈希函数 (Hash Function)**：作为随机预言机，将输入数据（标识符）映射到密码学群组中的元素，用于后续的密码学操作。
* **乱序 (Shuffle)**：在每一轮通信中，发送方都会对数据进行乱序处理，使得接收方无法根据消息的顺序将输入和输出关联起来，从而增强了隐私保护。

---

### **2. 协议参与方与输入**

* **参与方**:
    * `P1`: 协议参与方一。
    * `P2`: 协议参与方二。

* **公共参数**:
    * `G`: 一个素数阶 `q` 的群组。
    * `H`: 一个哈希函数，`H: L -> G`，被建模为随机预言机（Random Oracle）。它将一个标识符空间 `L` 中的元素映射到群 `G` 中的一个元素。

* **各方输入**:
    * **P1 的输入**: 一个集合 `P1`，包含 `n1` 个元素 `v_i`。形式为 `P1: Set V = {v_1, v_2, ..., v_n1}`，其中 `v_i` 属于标识符空间 `L`。
    * **P2 的输入**: 一个集合 `P2`，包含 `n2` 对数据 `(w_j, t_j)`。形式为 `P2: Set of pairs {(w_1, t_1), (w_2, t_2), ..., (w_n2, t_n2)}`，其中 `w_j` 属于标识符空间 `L`，而 `t_j` 是一个正整数（`t_j ∈ Z+`），代表与 `w_j` 关联的数值。

---

### **3. 协议详细步骤**

#### **Setup (设置阶段)**

1.  **P1 和 P2 选择私钥**:
    * `P1` 选择一个随机的私钥 `k1` (一个指数)。
    * `P2` 选择一个随机的私钥 `k2` (一个指数)。
    * 这两个私钥是保密的，不会泄露给对方。

2.  **P2 生成公私钥对**:
    * `P2` 运行一个加法同态加密方案的密钥生成算法 `AEncGen(λ)`，生成一个公钥 `pk` 和一个私钥 `sk`。（`λ` 是安全参数）。
    * `P2` 将生成的公钥 `pk` 发送给 `P1`。

#### **Round 1 (P1 -> P2)**

1.  **P1 处理其数据**:
    * 对于自己集合 `V` 中的每一个元素 `v_i`：
        * 首先，使用哈希函数 `H` 计算 `H(v_i)`。
        * 然后，使用自己的私钥 `k1` 进行指数运算，计算出 `H(v_i)^k1`。
    * 将所有计算出的结果 `{H(v_i)^k1}` 集合起来。

2.  **P1 发送数据**:
    * `P1` 将上一步生成的集合 `{H(v_i)^k1}` 进行 **乱序（Shuffle）** 处理，然后发送给 `P2`。

#### **Round 2 (P2 -> P1)**

此轮是协议的核心，`P2` 同时处理来自 `P1` 的数据和自己的数据。

1.  **P2 处理收到的数据**:
    * 对于从 `P1` 收到的每一个元素 `H(v_i)^k1`：
        * `P2` 使用自己的私钥 `k2` 对其进行指数运算，计算出 `(H(v_i)^k1)^k2`。

2.  **P2 生成集合 Z**:
    * `P2` 将上一步计算出的所有 `(H(v_i)^k1)^k2` 组成一个集合 `Z`。
    * `P2` 将集合 `Z` 进行 **乱序** 处理后发送给 `P1`。这一步的目的是让 `P1` 能够计算出交集，但无法将 `Z` 中的元素与自己原始的 `v_i` 对应起来。

3.  **P2 处理自己的数据**:
    * 对于自己集合中的每一对 `(w_j, t_j)`：
        * `P2` 计算 `H(w_j)^k2`。这是用自己的私钥对自己数据的第一部分进行处理。
        * `P2` 使用之前发送给 `P1` 的同态加密公钥 `pk`，加密关联值 `t_j`，得到密文 `AEnc(pk, t_j)`。

4.  **P2 发送另一组数据**:
    * `P2` 将上一步生成的所有数据对 `(H(w_j)^k2, AEnc(pk, t_j))` 组成一个集合。
    * `P2` 将该集合进行 **乱序** 处理，然后发送给 `P1`。

#### **Round 3 (P1 处理)**

`P1` 在这一轮中找出交集并计算关联值的加密总和。

1.  **P1 计算交集标识**:
    * 对于从 `P2` 收到的第二组数据中的每一个元素 `(H(w_j)^k2, AEnc(pk, t_j))`：
        * `P1` 使用自己的私钥 `k1` 对第一部分进行指数运算，得到 `(H(w_j)^k2)^k1`。

2.  **P1 确定交集 J**:
    * `P1` 将上一步计算出的 `(H(w_j)^k2)^k1` 与在 Round 2 中收到的集合 `Z`（其元素形式为 `(H(v_i)^k1)^k2`）进行比较。
    * 如果某个 `(H(w_j)^k2)^k1` 存在于集合 `Z` 中，则意味着 `H(w_j) = H(v_i)`，从而 `w_j = v_i`。这表明 `w_j` 是一个交集元素。
    * `P1` 构建交集 `J`，其中包含了所有满足 `(H(w_j)^k2)^k1 ∈ Z` 的 `(w_j)` 对应的加密值 `AEnc(pk, t_j)`。

3.  **P1 计算交集和的密文**:
    * `P1` 利用同态加密的加法特性，对交集 `J` 中的所有密文 `AEnc(pk, t_j)` 进行同态求和。
        * `ASum({AEnc(t_j)}) = AEnc(∑t_j)`
    * 计算结果 `S_J` 是一个加密了的交集总和。

4.  **P1 随机化并发送**:
    * `P1` 对求和后的密文 `S_J` 进行一次随机化操作（`ARefresh`），生成一个新的、与原密文等价但表现形式不同的密文。这一步是为了防止 `P2` 通过最终的密文猜测出任何关于交集大小或内容的信息。
    * `P1` 将这个随机化后的密文发送给 `P2`。

---

### **4. Output (输出)**

* **P2 解密**:
    * `P2` 收到 `P1` 发来的最终密文后，使用自己的同态加密私钥 `sk` 进行解密。
    * 解密后得到的结果就是最终的交集元素关联值之和 `S_J`。

### **5. 安全性与隐私保护分析**

* **P1 的隐私**: `P1` 的集合 `V` 是保密的。`P1` 只发送了经过哈希和私钥指数运算的值 `H(v_i)^k1`。由于 `k1` 是保密的，`P2` 无法从这些值反推出原始的 `v_i`。
* **P2 的隐私**: `P2` 的集合 `{(w_j, t_j)}` 也是保密的。
    * `w_j` 的隐私由 `k2` 保护，与 `P1` 类似。
    * `t_j` 的隐私由同态加密保护。`P1` 只能操作这些值的密文，无法得知任何单个 `t_j` 的具体数值。
* **交集的隐私**:
    * 对于 `P1`，它虽然可以确定哪些 `AEnc(pk, t_j)` 属于交集，但无法解密它们，因此不知道具体的关联值 `t_j`。
    * 对于 `P2`，它最终只得到一个总和 `S_J`，无法知道是哪些元素构成了交集，也无法知道交集的具体大小（因为`P1`返回的是一个聚合后的密文）。
* **DDH 假设的应用**: DDH 假设保证了，一个不知道 `k1` 或 `k2` 的攻击者，无法区分元组 `(g, g^k1, g^k2, g^(k1*k2))` 和 `(g, g^k1, g^k2, g^r)`（其中 `r` 是随机数）。这确保了 `P1` 和 `P2` 无法从交换的中间值中获得对方私钥的任何信息。
* **乱序的作用**: 乱序操作至关重要。它切断了输入和输出之间的直接联系。例如，如果没有乱序，`P2` 在 Round 2 中就可以将收到的 `H(v_i)^k1` 与自己计算出的 `(H(v_i)^k1)^k2` 一一对应，从而可能发起攻击。同样，`P1` 也无法将 `Z` 中的元素和自己的 `v_i` 直接关联。

综上所述，该协议通过多层密码学技术的组合，实现了一个强大且隐私保护特性良好的交集求和方案。

