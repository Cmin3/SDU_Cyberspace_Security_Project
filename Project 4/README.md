# SM3 密码杂凑算法原理详解

## 1. 概述

SM3是中国国家密码管理局发布的密码杂凑算法，适用于商用密码应用中的数字签名和验证、消息认证码的生成与验证以及随机数的生成。它输入任意长度的消息，输出一个256位的杂凑值。SM3算法的设计类似于SHA-256，采用了Merkle-Damgård结构。

算法的整个过程主要包括三个部分：**消息填充**、**消息扩展**和**迭代压缩**。

### 1.1. 算法中使用的符号

先定义一些基本操作和符号：

| 符号         | 描述             |
| :----------- | :--------------- |
| $\wedge$     | 按位与 (AND)     |
| $\vee$       | 按位或 (OR)      |
| $\oplus$     | 按位异或 (XOR)   |
| $\neg$       | 按位非 (NOT)     |
| $+$          | 模 $2^{32}$ 加法 |
| $<<<$        | 循环左移         |
| $\leftarrow$ | 赋值操作         |
| $||$         | 比特串拼接       |

所有的操作都是在32位的字（Word）上进行的。

## 2. 消息填充

由于SM3算法是按512位的分组来处理消息的，因此在计算之前，必须对输入的原始消息进行填充，使其长度成为512的整数倍。

假设原始消息为 $m$，其长度为 $l$ 比特。填充过程如下：

1.  **附加“1”**: 在消息 $m$ 的末尾附加一位“1”。
2.  **补“0”**: 接着，附加 $k$ 个“0”，其中 $k$ 是满足下列条件的最小非负整数：
    $$ l + 1 + k \equiv 448 \pmod{512} $$
3.  **附加原始长度**: 最后，再附加一个64位的比特串，该比特串是原始消息长度 $l$ 的二进制表示。

经过以上步骤，得到填充后的消息 $m'$，其长度为512的整数倍。然后将 $m'$ 按512位分为 $n$ 个分组：

$$ m' = B^{(0)} || B^{(1)} || \dots || B^{(n-1)} $$

其中 $n = (l + k + 65) / 512$。

## 3. 消息扩展

在对每个512位消息分组 $B^{(i)}$ 进行压缩之前，需要先对其进行扩展，生成132个32位的字（Word），用于压缩函数的计算。这个过程称为消息扩展。

对于一个消息分组 $B^{(i)}$，其扩展过程如下：

1.  **划分分组**: 将512位的消息分组 $B^{(i)}$ 划分为16个32位的字（Word）：$W_0, W_1, \dots, W_{15}$。

2.  **生成 $W_j$**: 按以下公式，从 $W_0, \dots, W_{15}$ 生成 $W_{16}, \dots, W_{67}$：
    $$ W_j = P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} \lll 15)) \oplus (W_{j-13} \lll 7) \oplus W_{j-6} $$
    这个迭代过程对 $j = 16, 17, \dots, 67$ 进行。其中 $P_1$ 是一个置换函数，定义为：
    $$ P_1(X) = X \oplus (X \lll 15) \oplus (X \lll 23) $$

3.  **生成 $W'_j$**: 为了在压缩过程中使用，还需要生成另一组64个字 $W'_0, \dots, W'_{63}$：
    $$ W'_j = W_j \oplus W_{j+4} $$
    这个过程对 $j = 0, 1, \dots, 63$ 进行。

## 4. 迭代压缩

迭代压缩是SM3算法的核心，它使用一个压缩函数 $CF$ 对每个扩展后的消息分组进行处理，并更新一个256位的中间哈希值。

### 4.1. 初始值 (IV)

算法使用一个256位的初始值 $IV$ 来初始化哈希寄存器。该 $IV$ 由8个32位的字组成：

$V^{(0)} = IV = A_0B_0C_0D_0E_0F_0G_0H_0$

其中：
- $A_0 = \text{0x7380166f}$
- $B_0 = \text{0x4914b2b9}$
- $C_0 = \text{0x172442d7}$
- $D_0 = \text{0xda8a0600}$
- $E_0 = \text{0xa96f30bc}$
- $F_0 = \text{0x163138aa}$
- $G_0 = \text{0xe38dee4d}$
- $H_0 = \text{0xb0fb0e4e}$

### 4.2. 压缩函数 $CF$

对于每个消息分组 $B^{(i)}$ ($i = 0, \dots, n-1$)，执行以下计算：

$V^{(i+1)} = CF(V^{(i)}, B^{(i)})$

压缩函数 $CF$ 的内部逻辑如下：

1.  **初始化寄存器**:
    - 将当前的256位中间哈希值 $V^{(i)}$ 分解为8个32位的寄存器：$A, B, C, D, E, F, G, H$。
    - 即 $(A, B, C, D, E, F, G, H) \leftarrow V^{(i)}$。

2.  **64轮迭代**:
    进行64轮迭代（$j = 0, 1, \dots, 63$），每轮更新寄存器的值。在第 $j$ 轮中，使用消息扩展生成的 $W_j$ 和 $W'_j$。

    - **计算中间变量**:
      $$ SS1 = ((A \lll 12) + E + (T_j \lll j)) \lll 7 $$
      $$ SS2 = SS1 \oplus (A \lll 12) $$
      $$ TT1 = FF_j(A, B, C) + D + SS2 + W'_j $$
      $$ TT2 = GG_j(E, F, G) + H + SS1 + W_j $$

    - **更新寄存器**:
      $$ D \leftarrow C $$
      $$ C \leftarrow B \lll 9 $$
      $$ B \leftarrow A $$
      $$ A \leftarrow TT1 $$
      $$ H \leftarrow G $$
      $$ G \leftarrow F \lll 19 $$
      $$ F \leftarrow E $$
      $$ E \leftarrow P_0(TT2) $$

3.  **更新中间哈希值**:
    将本轮压缩的输出与输入的中间哈希值进行异或运算，得到新的中间哈希值：
    $$ V^{(i+1)} \leftarrow (A || B || C || D || E || F || G || H) \oplus V^{(i)} $$

### 4.3. 关键函数和常量

在压缩函数中，使用了一些布尔函数、置换函数和常量，它们的定义随迭代轮数 $j$ 的变化而变化。

- **常量 $T_j$**:
  $$ T_j = \begin{cases} \text{0x79cc4519} & 0 \le j \le 15 \\ \text{0x7a879d8a} & 16 \le j \le 63 \end{cases} $$

- **布尔函数 $FF_j$**:
  $$ FF_j(X, Y, Z) = \begin{cases} X \oplus Y \oplus Z & 0 \le j \le 15 \\ (X \wedge Y) \vee (X \wedge Z) \vee (Y \wedge Z) & 16 \le j \le 63 \end{cases} $$

- **布尔函数 $GG_j$**:
  $$ GG_j(X, Y, Z) = \begin{cases} X \oplus Y \oplus Z & 0 \le j \le 15 \\ (X \wedge Y) \vee (\neg X \wedge Z) & 16 \le j \le 63 \end{cases} $$

- **置换函数 $P_0$**:
  $$ P_0(X) = X \oplus (X \lll 9) \oplus (X \lll 17) $$

## 5. 输出最终杂凑值

在处理完所有 $n$ 个消息分组后，得到的 $V^{(n)}$ 就是最终的杂凑值。将 $V^{(n)}$ 的8个32位字按大端序拼接起来，就得到了256位的最终输出结果。

$$ \text{Hash} = V^{(n)} = V^{(n)}_A || V^{(n)}_B || V^{(n)}_C || V^{(n)}_D || V^{(n)}_E || V^{(n)}_F || V^{(n)}_G || V^{(n)}_H $$