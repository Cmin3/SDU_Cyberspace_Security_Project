# SM2算法实现与安全分析项目

## 一、项目概述

本项目实现了中国商用密码标准SM2算法的Python版本，包含基础实现和优化版本，并针对SM2签名算法的常见误用场景进行了安全分析和验证。项目主要包含以下内容：
1. SM2基础算法实现
2. 性能优化实现（使用gmpy2加速）
3. 随机数k泄露攻击验证
4. 数字签名伪造演示（包括中本聪签名伪造案例）

## 二、算法原理详解

### 1. SM2基础算法

SM2是基于椭圆曲线的数字签名算法，主要特点包括：
- 使用推荐椭圆曲线参数（256位素数域）
- 签名过程包含用户身份信息ZA
- 采用SM3哈希算法
- 签名公式：`s = (1+dA)^-1 * (k - r*dA) mod n`

### 2. 安全风险分析

#### 随机数k泄露攻击
- 若签名随机数k泄露，可直接计算私钥
- 恢复公式：`dA = (k-s) * (s+r)^-1 mod n`

#### 签名伪造攻击
- 当验证过程直接接受外部哈希值时，可构造满足数学关系但不对应真实消息的签名
- 利用椭圆曲线点运算性质构造伪造签名

## 三、文件说明

### 核心实现文件

1. `sm2_base.py`：SM2基础实现
   - 纯Python实现
   - 包含密钥生成、签名和验证
   - 集成SM3哈希算法

2. `sm2_acc.py`：优化实现
   - 使用gmpy2加速大数运算
   - 性能提升约40%
   - 相同功能接口

3. `sm2_poc.py`：安全验证
   - 随机数k泄露攻击演示
   - 完整私钥恢复过程

4. `sm2_zbc.py`：签名伪造
   - 中本聪签名伪造案例
   - 脆弱验证与安全验证对比

## 四、运行结果

### 1. 基础测试结果

```
签名1000次耗时: 5.0076秒, 平均每次: 5.0076毫秒
验签1000次耗时: 5.7117秒, 平均每次: 5.7117毫秒
所有验签结果正确 ✅
```

### 2. 加速算法测试结果

```
签名100次耗时: 2.9172秒, 平均每次: 2.9172毫秒
验签100次耗时: 3.2016秒, 平均每次: 3.2016毫秒
所有验签结果正确 ✅
```

### 3. POC测试结果

```
--- PoC: 随机数 k 泄露攻击 ---
  - 原始私钥: 0x8a5b4efcecdbe2ded553e0ab94bc8e346e332f5f13d45df1a4536b63cedaa813
  - 泄露的 k: 0x62bec39b236ec95b6b201256f383c48fa55759fae55516392aaeb5eb58a67135
  - 生成的签名 (r, s): (0x3775ce0d737e5697e58de340d0b12082054d7fc7f790d820e43f571376e882f4, 0x76897c28a0ba017f5bbb10077dbb5104ff00200d6958b24c92ff03543bde91c)
  - 恢复的私钥: 0x8a5b4efcecdbe2ded553e0ab94bc8e346e332f5f13d45df1a4536b63cedaa813
  - [成功] 恢复的私钥与原始私钥匹配！
```

### 4. 伪造中本聪签名测试结果

```
--- 密钥信息 ---
私钥 (十六进制): bdf4de43e6658d3578fe9325f4cd75489d10d4c07125d48aab76df659ac52217
公钥 (十六进制): 031d036d7156f2263350e2299fc76db158938832faccb2f6a068e9cbd3c8a364e7
------------------------------------------------------------
--- 攻击场景 ---
攻击者想要伪造对以下消息的签名:
'I, Satoshi Nakamoto, hereby transfer 1 million BTC to the attacker's address.'
------------------------------------------------------------
--- 开始伪造签名 (无需私钥) ---
1. 攻击者选择随机数 u1, u2
2. 计算伪造点 R' = u1*G + u2*pubKey
3. 构造伪造签名 r' 和 s'
   伪造的 r' = 28341457380924960771447415746463845089225590961668979994037933255333480069009
   伪造的 s' = 59905069569851447541696707832157449805510611739546170705670686385710835579516
4. 构造可通过验证的伪造哈希 e'
   伪造的 e' (整数形式) = 35376079812657875872621294335624205101574872210956398119501940048299760416445
------------------------------------------------------------
--- 场景A: 脆弱的验证过程 ---
验证者直接使用攻击者提供的伪造哈希进行验证...

验证结果: True
✅ 攻击成功！伪造的签名通过了脆弱的验证。
   这意味着，验证者错误地相信了中本聪签署了伪造的消息。
------------------------------------------------------------
--- 场景B: 安全的验证过程 ---
验证者忽略外部哈希，独立对伪造的消息进行哈希计算...
伪造消息的真实哈希 (bytes): 6cd3c82efac2921e9e59378f73bf0ef3cc39db59684ce7e0976d6d6c609e5b28
攻击者构造的伪造哈希 (bytes): 4e3626d0487f9bbaaa6b47d0fe7d48cc1dbb03a0361d4604136628fef401f6bd

验证结果: False
✅ 防御成功！伪造的签名未能通过安全的验证。
   因为签名的数学关系与消息的真实哈希不匹配。
------------------------------------------------------------
```

## 五、构建与运行

### 环境准备

```bash
pip install gmpy2 ecdsa
```

### 运行测试

1. 基础性能测试：
```bash
python sm2_base.py
python sm2_acc.py
```

2. 安全验证：
```bash
python sm2_poc.py
python sm2_zbc.py
```

## 六、实现特点

1. **完整性**
   - 完整实现SM2签名算法
   - 包含SM3哈希算法
   - 覆盖密钥生成到验证全流程
2. **安全性**
   - 演示典型安全风险
   - 对比脆弱与安全验证
   - 提供攻击原理分析
4. **性能**
   - 基础与优化实现对比
   - 使用高效数学库
   - 模块化设计



